# **디자인 패턴을 이용해 문제를 해결하는 방법**
## **적당한 객체 찾기**
1. 객체지향 프로그램은 객체로 만듭니다.
2. 객체는 데이터와 이 데이터로 연산을 하는 메서드를 함께 묶는 단위입니다.
3. 객체는 사용자로부터 요청(request)를 받으면 연산(method)을 수행합니다.
4. 이러한 요청은 객체가 연산을 수행하게 하는 유일한 방법이고 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법입니다.
5. 이러한 접근 제약으로 객체의 내부 상태는 **캡슐화(encapsulate)** 된다고 합니다.
6. 설계 단계의 객체 대부분은 분석 모델에서부터 만들어진 것입니다. 객체지향 설계는 실세계와 대응 관계를 갖지 못할 때가 많습니다. 즉, 분석 모델의 객체는 실세계 객체들이지만(구체), 설계 모델의 객체에는 구현에 가까운 클래스들도 있습니다(추상). 디자인 패턴은 추상적 개념과 이것을 구현한 객체를 알아보는데 도움을 줍니다.

## **객체 인터페이스의 명세**
1. 객체가 선언하는 모든 메서드는 메서드 이름, 매개변수, 메서드의 반환 값을 명세합니다. 이를 메서드 **시그니처(signature)** 라고 합니다.
2. **인터페이스(interface)** 는 객체가 정의하는 연산의 모든 시그니처들을 일컫는 말로 객체의 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합입니다.
3. 타입(Type)은 특정 인터페이스를 나타낼 때 사용하는 이름입니다. 객체가 A 타입을 갖는다는 것은 A 인터페이스에 정의한 연산들을 모두 처리할 수 있다는 것을 의미합니다.
4. 다른 인터페이스를 포함하는 인터페이스를 **서브타입(subtype)** 이라고 하고, 다른 인터페이스가 포함하는 인터페이스를 **슈퍼타입(supertype)** 이라고 합니다.
5.서브타입은 슈퍼타입의 인터페이스를 **상속(inherit)** 한다고 말합니다.
6. 객체는 인터페이스로 자신을 드러냅니다. 외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없기 때문에 인터페이스를 통해서만 처리를 요청할 수 있습니다.
7. 객체의 인터페이스는 구현에 대해선 아무것도 알려주지 않습니다. 그러므로 서로 다른 객체는 인터페이스에 정의한 요청의 구현 방법을 자유롭게 선택할 수 있습니다.
8. 이렇게 동일한 인터페이스를 갖는 서로 다른 객체는 구현 방법이 다를 수 있고 그에 따라 반환 값도 달라질 수 있습니다. 이 때 특정 요청과 그 요청을 처리할 객체를 프로그램 실행 중, 즉 런타임에 연결 짓는 것을 **동적 바인딩(dynamic binding)** 이라고 합니다.
9. 이렇게 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있도록 하는 것을 **다형성(polymorphism)** 이라고 합니다. 이러한 다형성은 다음 특징을 갖습니다.
   - 사용자의 정의를 단순화하고
   - 객체 간의 결합도를 없애며
   - 런타임 중에 서로 간의 관련성을 다양화할 수 있게 해줍니다.

## **객체 구현 명세하기**
1. 객체의 구현을 정의(define)하는 방법 중 하나는 **클래스(class)** 를 사용하는 것입니다.
2. 객체는 클래스를 인스턴스로 만들어서 생성합니다. 즉, 객체는 클래스의 **인스턴스(instance)** 라고 할 수 있습니다.
3. 새로운 클래스(subclass)는 기존 클래스(parent class)에 기반을 둔 클래스 상속을 사용하여 정의할 수 있습니다.
4. **추상 클래스(abstract class)** 는 모든 서브클래스 사이의 공통되는 인터페이스를 정의합니다.
5. 추상 클래스가 아닌 클래스를 **구체 클래스(concrete class)** 라고 합니다.
6. 서브클래스는 부모 클래스가 정의한 행동을 재정의하거나 정제할 수 있습니다. 이를 **오버라이드(override)** 라고 합니다.
7. **믹스인(mixin)** 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스 입니다. 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷합니다.
### **# 추상 클래스와 인터페이스의 차이**
[What is the difference between an interface and abstract class?
](https://stackoverflow.com/questions/1913098/what-is-the-difference-between-an-interface-and-abstract-class)
- 추상 클래스는 인터페이스와 달리 클래스 입니다. 따라서 상속받는 클래스가 구현해야만 하는 것을 추상적으로 정의할 수 있고 공통적으로 사용되는 것은 메서드 혹은 속성으로 정의할 수 있습니다.
```typescript
// 나: 모든 오토바이는 이래야해:
interface MotorVehicle {
  run(): void;
  getFuel(): number;
}

// 팀원: 인터페이스를 참고해서 오토바이를 구현!
class Car implements MotorVehicle {
  public fuel: number;

  run() {
    console.log("Wrroooooooom");
  }

  getFuel() {
    return this.fuel;
  }
}
```
```typescript
// 나: 모든 오토바이는 이래야해:
abstract class MotorVehicle {
  public fuel: number;

  // 모든 오토바이는 연료를 갖기 때문에 상속받는 모두를 위해 구현할게
  getFuel() {
    return this.fuel;
  }

  // 이 메서드는 사람마다 매우 다르게 정의할 수 있겠어. 하지만 반드시 만들어야 하니까 abstract를 통해 구현하도록 강제해야지
  abstract run(): void;
}

// 팀원: 추상 클래스를 참고해서 오토바이를 구현!
class Car extends MotorVehicle {
  run() {
    console.log("Wrroooooooom");
  }
}
```
